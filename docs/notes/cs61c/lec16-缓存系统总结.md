---
title: lec16-缓存系统总结
tags:
  - cs61c
  - 缓存
categories: dairy
date: " 2025-02-14T01:31:38+08:00 "
modify: " 2025-02-14T01:31:38+08:00 "
dir: dairy
share: false
cdate: " 2025-02-14 "
mdate: " 2025-02-14 "
---

# lec16-缓存系统总结

---

## 1. 缓存术语与指标

| 术语                | 定义                      |
| ----------------- | ----------------------- |
| 缓存命中 Hit          | 目标数据在缓存中找到              |
| 缓存未命中 Miss        | 目标数据不在缓存中，需从主存加载        |
| 命中率 Hit Rate      | 命中次数 / 总访问次数            |
| 命中耗时 Hit Time     | 命中时，从缓存加载数据的时间          |
| 缺失惩罚 Miss Penalty | 未命中时，从主存加载数据到缓存的额外时间    |
| 有效位               | 标识缓存行是否有效（1=有效，0=无效）    |
| 脏位                | 标识缓存行是否被修改（写回策略中需同步到主存） |

---

## 2. 缓存行/块

- **缓存行/块大小**：缓存加载的最小单位（如64Bytes）。  
- **示例**：访问字节地址`199`未命中时，加载整个块`192-255`。  
- **优势**：利用空间局部性，减少频繁访问邻近地址的缺失。

---

## 3. 缓存策略

### 写策略

| 策略            | 行为                         |
| ------------- | -------------------------- |
| Write-through | 同时更新缓存和主存，实现简单但增加内存流量。     |
| Write-back    | 仅更新缓存并标记脏位，替换时写回主存，减少内存流量。 |

### 写分配策略

| 策略                | 行为                   |
| ----------------- | -------------------- |
| Write-allocate    | 写未命中时加载块到缓存并更新。      |
| No Write-allocate | 写未命中时直接更新主存，不加载块到缓存。 |

### 常见组合

- Write through, no write-allocate
	- write hits 时，缓存和内存同时更新
	- write misses 时，不加载块到缓存，直接更新内存
	- read misses 时，加载块到缓存
- Write back, write-allocate
	- write / read misses, 加载块到缓存
	- write hits 时，只更新缓存与脏位
---

## 4. 驱逐策略（Evistion Policies）

### 近似LRU（时钟算法）

- **机制**：  
  1. 每行包含一个引用位（`Referenced Bit`）。  
  2. 未命中时，按顺序扫描行：  
     - 引用位=1 → 置0，继续扫描。  
     - 引用位=0 → 替换该行。  

### 其他策略

- **MRU**：替换最近使用的行（适合循环访问模式）。  
- **随机替换**：无需跟踪元数据，但命中率不稳定。
- 这两个策略优于 MRU 的例子
	- 4 个缓存页，依次访问 5 个位于不同页的元素
	- LRU 0% hit rate
	- MRU 75% hit rate
	- Random non-zero hit rate

---

## 5. 缓存类型

### 全相联缓存

- **特点**：数据可存于任意缓存行，需复杂替换策略（如LRU）。  
- **地址分解**：  

  ```
  全地址 =  Tag | Byte Offset  
  前面每个 占1bit  
  #offset_bits = log2(块大小)
  #tag_bits = 地址总位数 - #offset_bits
   
  ```

### 直接映射缓存

- **特点**：数据只能存于固定索引位置，冲突率高。  
- **地址分解**：  

  ```
  全地址 = Index | Byte Offset
  #TIO
  ```

### 组相联缓存

- **特点**：数据存于固定索引的组内（组内多行），平衡冲突与复杂度。  
- **地址分解**：  

  ```
  全地址 = Tag | Index | Byte Offset
  #index_bits = log2(组数)
  ```

---

## 6. 地址分解与硬件实现

### 示例：32位地址，4KB缓存，16B块

- **参数计算**：  

  ```plaintext
  #offset_bits = log2(16) = 4
  #lines = 4KB / 16B = 256 → #index_bits = log2(256) = 8
  #tag_bits = 32 - 8 - 4 = 20
  ```

- **地址格式**：  

  ```
  | 31-12 (20位Tag) | 11-4 (8位Index) | 3-0 (4位Offset) |
  ```

### 硬件结构

- **直接映射缓存硬件**：  

  ```plaintext
  输入地址 → 提取Index → 匹配Tag → 检查有效位 → 返回数据。
  ```

---

## 7. 缺失类型

| 类型         | 原因                                                                 |
|--------------|----------------------------------------------------------------------|
| 强制缺失     | 首次访问某块，必然缺失。                                             |
| 容量缺失     | 缓存容量不足，替换后重新加载旧块。                                   |
| 冲突缺失     | 多块竞争同一索引（直接映射/组相联中特有）。                          |
